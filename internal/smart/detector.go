package smart

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/entro314-labs/cool-kit/internal/detect"
)

// DeploymentConfig represents the complete deployment configuration
type DeploymentConfig struct {
	Framework      *detect.FrameworkInfo
	Services       []RequiredService
	Environment    []EnvironmentVariable
	DeploymentMode string // "production" or "preview"
	AutoGenerated  bool
}

// RequiredService represents a service needed by the application
type RequiredService struct {
	Type       string // "postgresql", "redis", "mysql", "mongodb", etc.
	Version    string
	Reason     string // Why this service is needed
	EnvVarName string // Environment variable name for connection
	Required   bool   // Is this absolutely required or optional?
}

// EnvironmentVariable represents an env var that needs to be set
type EnvironmentVariable struct {
	Key         string
	Value       string
	Description string
	Secret      bool
	AutoGen     bool // Can we auto-generate this (like DB URLs)?
}

// SmartDetector performs intelligent project analysis
type SmartDetector struct {
	projectPath string
	framework   *detect.FrameworkInfo
}

// NewSmartDetector creates a new smart detector
func NewSmartDetector(projectPath string) *SmartDetector {
	return &SmartDetector{
		projectPath: projectPath,
	}
}

// Detect performs comprehensive project analysis
func (sd *SmartDetector) Detect() (*DeploymentConfig, error) {
	// Detect framework
	framework, err := detect.Detect(sd.projectPath)
	if err != nil {
		return nil, fmt.Errorf("failed to detect framework: %w", err)
	}
	sd.framework = framework

	config := &DeploymentConfig{
		Framework:      framework,
		Services:       []RequiredService{},
		Environment:    []EnvironmentVariable{},
		DeploymentMode: "production",
		AutoGenerated:  true,
	}

	// Detect required services
	services, err := sd.detectServices()
	if err == nil {
		config.Services = services
	}

	// Detect environment variables
	envVars, err := sd.detectEnvironmentVariables()
	if err == nil {
		config.Environment = envVars
	}

	return config, nil
}

// detectServices analyzes the project to determine required services
func (sd *SmartDetector) detectServices() ([]RequiredService, error) {
	services := []RequiredService{}

	// Check for database dependencies
	if dbService := sd.detectDatabase(); dbService != nil {
		services = append(services, *dbService)
	}

	// Check for cache/Redis
	if cacheService := sd.detectCache(); cacheService != nil {
		services = append(services, *cacheService)
	}

	// Check for queue system
	if queueService := sd.detectQueue(); queueService != nil {
		services = append(services, *queueService)
	}

	// Check for search (Elasticsearch, Meilisearch, etc.)
	if searchService := sd.detectSearch(); searchService != nil {
		services = append(services, *searchService)
	}

	return services, nil
}

// detectDatabase detects database requirements
func (sd *SmartDetector) detectDatabase() *RequiredService {
	// Check package.json for database packages
	if sd.framework.Name == "Next.js" || sd.framework.Name == "Node.js" ||
		sd.framework.Name == "NestJS" || sd.framework.Name == "Express" {

		packageJSON := filepath.Join(sd.projectPath, "package.json")
		if content, err := os.ReadFile(packageJSON); err == nil {
			contentStr := string(content)

			// PostgreSQL
			if strings.Contains(contentStr, "\"pg\"") ||
				strings.Contains(contentStr, "\"postgres\"") ||
				strings.Contains(contentStr, "\"@prisma/client\"") ||
				strings.Contains(contentStr, "\"drizzle-orm\"") {
				return &RequiredService{
					Type:       "postgresql",
					Version:    "16",
					Reason:     "Detected PostgreSQL client in dependencies",
					EnvVarName: "DATABASE_URL",
					Required:   true,
				}
			}

			// MySQL
			if strings.Contains(contentStr, "\"mysql\"") ||
				strings.Contains(contentStr, "\"mysql2\"") {
				return &RequiredService{
					Type:       "mysql",
					Version:    "8",
					Reason:     "Detected MySQL client in dependencies",
					EnvVarName: "DATABASE_URL",
					Required:   true,
				}
			}

			// MongoDB
			if strings.Contains(contentStr, "\"mongodb\"") ||
				strings.Contains(contentStr, "\"mongoose\"") {
				return &RequiredService{
					Type:       "mongodb",
					Version:    "7",
					Reason:     "Detected MongoDB client in dependencies",
					EnvVarName: "MONGODB_URL",
					Required:   true,
				}
			}
		}
	}

	// Check for Laravel (Composer)
	if sd.framework.Name == "Laravel" {
		composerJSON := filepath.Join(sd.projectPath, "composer.json")
		if _, err := os.Stat(composerJSON); err == nil {
			// Laravel typically uses MySQL or PostgreSQL
			return &RequiredService{
				Type:       "postgresql", // Default to PostgreSQL
				Version:    "16",
				Reason:     "Laravel application detected",
				EnvVarName: "DATABASE_URL",
				Required:   true,
			}
		}
	}

	// Check for .env file hints
	envFile := filepath.Join(sd.projectPath, ".env.example")
	if content, err := os.ReadFile(envFile); err == nil {
		contentStr := string(content)
		if strings.Contains(contentStr, "DATABASE_URL") || strings.Contains(contentStr, "DB_") {
			// Default to PostgreSQL if we see database env vars
			return &RequiredService{
				Type:       "postgresql",
				Version:    "16",
				Reason:     "Database configuration found in .env.example",
				EnvVarName: "DATABASE_URL",
				Required:   true,
			}
		}
	}

	return nil
}

// detectCache detects cache/Redis requirements
func (sd *SmartDetector) detectCache() *RequiredService {
	// Check package.json for Redis
	if sd.framework.Name == "Next.js" || sd.framework.Name == "Node.js" {
		packageJSON := filepath.Join(sd.projectPath, "package.json")
		if content, err := os.ReadFile(packageJSON); err == nil {
			contentStr := string(content)
			if strings.Contains(contentStr, "\"redis\"") ||
				strings.Contains(contentStr, "\"ioredis\"") ||
				strings.Contains(contentStr, "@upstash/redis") {
				return &RequiredService{
					Type:       "redis",
					Version:    "7",
					Reason:     "Redis client found in dependencies",
					EnvVarName: "REDIS_URL",
					Required:   false,
				}
			}
		}
	}

	// Check for Laravel cache configuration
	if sd.framework.Name == "Laravel" {
		configCache := filepath.Join(sd.projectPath, "config", "cache.php")
		if content, err := os.ReadFile(configCache); err == nil {
			if strings.Contains(string(content), "redis") {
				return &RequiredService{
					Type:       "redis",
					Version:    "7",
					Reason:     "Redis cache configured in Laravel",
					EnvVarName: "REDIS_URL",
					Required:   false,
				}
			}
		}
	}

	return nil
}

// detectQueue detects queue system requirements
func (sd *SmartDetector) detectQueue() *RequiredService {
	// Check for Laravel queues
	if sd.framework.Name == "Laravel" {
		configQueue := filepath.Join(sd.projectPath, "config", "queue.php")
		if _, err := os.Stat(configQueue); err == nil {
			return &RequiredService{
				Type:       "redis",
				Version:    "7",
				Reason:     "Laravel queue system detected",
				EnvVarName: "QUEUE_URL",
				Required:   false,
			}
		}
	}

	// Check for BullMQ, Bull, or other Node.js queue systems
	packageJSON := filepath.Join(sd.projectPath, "package.json")
	if content, err := os.ReadFile(packageJSON); err == nil {
		contentStr := string(content)
		if strings.Contains(contentStr, "\"bullmq\"") ||
			strings.Contains(contentStr, "\"bull\"") {
			return &RequiredService{
				Type:       "redis",
				Version:    "7",
				Reason:     "Queue system (BullMQ/Bull) detected",
				EnvVarName: "QUEUE_URL",
				Required:   false,
			}
		}
	}

	return nil
}

// detectSearch detects search engine requirements
func (sd *SmartDetector) detectSearch() *RequiredService {
	packageJSON := filepath.Join(sd.projectPath, "package.json")
	if content, err := os.ReadFile(packageJSON); err == nil {
		contentStr := string(content)

		// Meilisearch
		if strings.Contains(contentStr, "meilisearch") {
			return &RequiredService{
				Type:       "meilisearch",
				Version:    "latest",
				Reason:     "Meilisearch client detected",
				EnvVarName: "MEILISEARCH_URL",
				Required:   false,
			}
		}

		// Elasticsearch
		if strings.Contains(contentStr, "elasticsearch") ||
			strings.Contains(contentStr, "@elastic/elasticsearch") {
			return &RequiredService{
				Type:       "elasticsearch",
				Version:    "8",
				Reason:     "Elasticsearch client detected",
				EnvVarName: "ELASTICSEARCH_URL",
				Required:   false,
			}
		}
	}

	return nil
}

// detectEnvironmentVariables detects required environment variables
func (sd *SmartDetector) detectEnvironmentVariables() ([]EnvironmentVariable, error) {
	envVars := []EnvironmentVariable{}

	// Read .env.example if it exists
	envExamplePath := filepath.Join(sd.projectPath, ".env.example")
	if content, err := os.ReadFile(envExamplePath); err == nil {
		lines := strings.Split(string(content), "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if line == "" || strings.HasPrefix(line, "#") {
				continue
			}

			parts := strings.SplitN(line, "=", 2)
			if len(parts) >= 1 {
				key := strings.TrimSpace(parts[0])
				value := ""
				if len(parts) == 2 {
					value = strings.TrimSpace(parts[1])
				}

				// Skip database URLs - we'll auto-generate these
				if strings.Contains(key, "DATABASE_URL") ||
					strings.Contains(key, "REDIS_URL") {
					continue
				}

				isSecret := strings.Contains(key, "SECRET") ||
					strings.Contains(key, "KEY") ||
					strings.Contains(key, "PASSWORD") ||
					strings.Contains(key, "TOKEN")

				envVars = append(envVars, EnvironmentVariable{
					Key:         key,
					Value:       value,
					Description: fmt.Sprintf("Required by %s", sd.framework.Name),
					Secret:      isSecret,
					AutoGen:     false,
				})
			}
		}
	}

	return envVars, nil
}
